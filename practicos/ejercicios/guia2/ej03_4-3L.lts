 /* Concurrency: State Models & Java Programs                              
 *  Jeff Magee & Jeff Kramer
 *  Solutions to Exercises
 *
 *  Exercise 4.3
 */

/*
const Libre = 0
const Ocupado = 1
range Estado = Libre .. Ocupado

//modelo p/cada asiento 
ASIENTO = ASIENTO[Libre],  //el "cero" es libre, el "uno" ocupado
ASIENTO[i:Estado] = (when (i==Libre) reservar -> ASIENTO[Ocupado]
               	    |solicitar[i] -> ASIENTO[i]
                    |when (i==Ocupado) reservar -> ERROR   //se quiere reservar cuando ya esta ocupado
                    ).

range Numero = 1..2
||ASIENTOS = (butaca[Numero]:ASIENTO).  //todos son igualmente accesibles

TERMINAL = (elegir[j:Numero]
		   -> butaca[j].solicitar[v:Estado]
           -> if (v==Libre) then
			  	(butaca[j].reservar -> TERMINAL)
			  else
				TERMINAL
		   ).

set Terminal = {a,b}

||CONCIERTO = (Terminal:TERMINAL || Terminal::ASIENTOS).
*/


const False = 0
const True = 1
range Bool = False..True

SEAT = SEAT[False],
SEAT[reserved:Bool]
	= ( when (reserved==False) reserve -> SEAT[True]
	  | query[reserved] -> SEAT[reserved]
	  | when (reserved==True) reserve -> ERROR  //error of reserved twice
	  ).

range Seats = 1..2
||SEATS = (seat[Seats]:SEAT).

TERMINAL = (choose[s:Seats] -> acquire
		   -> seat[s].query[reserved:Bool]
		   -> if (reserved==False) then
				(seat[s].reserve -> release -> TERMINAL)
			  else
				(release -> TERMINAL)
			).

LOCK = (acquire -> release -> LOCK).

set Terminals = {a,b}

||CONCERT = ( Terminals:TERMINAL || Terminals::SEATS || Terminals::LOCK ).
