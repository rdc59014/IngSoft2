// recordar: a -> b -> C === a -> (b -> C)
// recordar: STOP es necesario para terminar.
// recordar: [i:0..N] debe empezar en 0!
SW = OFF,
OFF = (on -> ON),
ON = (off -> OFF).

//||PS = (pasillo:SW).

MEETING = (hello -> converse -> goodbye -> STOP).

//||MEETING = (MEETING). 

JOB = (arrive -> work -> leave -> JOB).

//||JOB = JOB.

GAME = (three -> lose -> GAME
       |{one, two} -> win -> GAME).

// GAME = (
//      one -> win -> GAME
//     |two -> win -> GAME
//     |three -> loose -> GAME
// ).

//||GAME = GAME.

MOVE = (ahead -> right -> MOVE
       |left -> STOP).
//||MOVE = MOVE.

/* Processes may be parameterized so that they may be described in a general form and
modeled for a particular parameter value. For instance, the single-slot buffer described
in section 2.1.3 and illustrated in Figure 2.10 can be described as a parameterized
process for values in the range 0 to N as follows: */
const N = 4
TICK (N=N) = TICK[0],
TICK[i:0..N] = (when (i<N) tick -> TICK[i+1]).
// ||TICK = (TICK).

const N2 = 4
COUNT (N2=N2) = COUNT[0],
COUNT[i:0..N2] = (when (i<N2) inc -> COUNT[i+1]
                 |when (i>0) dec -> COUNT[i-1]).
// ||COUNT = (COUNT).

const N3 = 5
COUNTDOWN (N3=N3) = COUNTDOWN[0],
COUNTDOWN[i:0..N3] = (when (i==0) start -> COUNTDOWN[i+1]
                     |when (0<i && i<N3-1) tick -> COUNTDOWN[i+1]
                     |when (0<i && i<N3) stop -> COUNTDOWN[N3]
                     |when (i==N3-1) beep -> COUNTDOWN[i+1]).

// ||COUNTDOWN = (COUNTDOWN). 

const N4 = 4
COUNTDOWN2 (N4=N4) = (start -> COUNTDOWN2[0]),
COUNTDOWN2[i:0..N4] = (when (i<N4-1) tick -> COUNTDOWN2[i+1]
                     |when (i<N4) stop -> COUNTDOWN2[N4]
                     |when (i==N4-1) beep -> COUNTDOWN2[i+1]).

// ||COUNTDOWN2 = (COUNTDOWN2). 

/* 
Hay 6 estados pero puedo separar en
4 estados (0,1,2,3), mas el inicial que esta implicito en el proceso (start -> COUNTDOWN3[N5]), y el final en el STOP.
*/
const N5 = 3
COUNTDOWN3 /*(N5=N5)*/ = (start -> COUNTDOWN3[N5]),
COUNTDOWN3[i:0..N5] = (when (i>0) tick -> COUNTDOWN3[i-1]
                     |when (i==0) beep -> STOP
                     |stop -> STOP).

// ||COUNTDOWN3 = COUNTDOWN3.

const N6 = 3
DOUBLE = (in[i:1..N6] -> out[i] -> DOUBLE).
// equivalente a
// DOUBLE = (in[1] -> out[1] -> DOUBLE
//          |in[2] -> out[2] -> DOUBLE
//          |in[3] -> out[3] -> DOUBLE).

// ||DOUBLE = DOUBLE.

PERSON = (tomorrow_work -> sleep -> work -> PERSON
         |tomorrow_weekend -> sleep -> {shop, play} -> PERSON).

// ||PERSON = PERSON.


// ej4
const N7 = 2
// VARIABLE = (write[i:0..N7] -> read[i] -> VARIABLE).
VARIABLE = (write[i:0..N7] -> WRITTEN[i]),
WRITTEN[j:0..N7] = (read[j] -> WRITTEN[j]
                   |write[n:0..N7] -> WRITTEN[n]).
// VARIABLE = (write[i:0..N7] -> (read[i] -> VARIABLE | hi[i] -> VARIABLE)).

// ||VARIABLE = VARIABLE. 


// ej5
BIESTABLE = (trigger -> one -> trigger -> zero -> BIESTABLE).
// BIESTABLE = BIESTABLE[0],
// BIESTABLE[i:0..1] = (
// 	when(i==0) trigger -> uno -> BIESTABLE[(i+1)%2]
// 	|when(i==1) trigger -> cero -> BIESTABLE[(i+1)%2]).
// ||BIESTABLE = BIESTABLE.

// ej6
SENSOR = SENSOR[5],
SENSOR[i:0..9] = (leer[j:0..9] -> (when(j<2) bajo -> SENSOR[j]
                                  |when(j>5) alto -> SENSOR[j]
                                  |when(j>=2 && j<=5) normal -> SENSOR[j])).
// ||SENSOR = SENSOR.

// ej9

P = (yoviajo -> charlamos -> P). 
Q = (tuviajas -> charlamos -> Q).
S2 = (yoviajo -> tuviajas -> charlamos -> S2 | tuviajas -> yoviajo -> charlamos -> S2).
// ||S1 = (P || Q).
// ||S2 = (S2).


// ej8 - ejercicio 8
// version sincrona
const MMAX = 5
const MMIN = 1
MRADIO = (
      on -> STATION[MMAX]
    | off -> MRADIO),
STATION[n:MMIN..MMAX] = (
          when(MMIN<n) scan -> STATION[n-1]
        | when(n==MMIN) scan -> STATION[MMAX]
        | reset -> STATION[MMAX]
        | off -> MRADIO
        | econtre_estacion -> STATION[n]).


// const MMAX = 4
// const MMIN = 0
SWITCH = (on -> ON),
ON = ({scan, reset} -> ON
     |off -> SWITCH).

// bien segun el profe aunque no era necesario hacerlo multiproceso
SCANNER = SCANNER[MMAX+1],
SCANNER[i:MMIN-1..MMAX+1] = (when(i==MMAX+1) scan -> SCANNER[i-1]
                            |when(i>=MMIN && i<=MMAX) station[i] -> SCANNER[i-1]
                            |when(i>=MMIN && i<=MMAX) lock -> LOCK[i]
                            |when(i==MMIN) end -> SCANNER[i-1]
                            |{reset, off} -> SCANNER[MMAX+1]),
LOCK[j:MMIN..MMAX] = (scan -> SCANNER[j-1]
                     |{reset, off} -> SCANNER[MMAX+1]).
// ||RADIO = (SWITCH||SCANNER).

//mejor?
// SCANNER = LOCK[MMAX],
// LOCK[j:MMIN..MMAX] = (scan -> SCANNER[j-1]
//                      |{reset, off} -> LOCK[MMAX]),
// SCANNER[i:MMIN-1..MMAX] = (when(i>=MMIN && i<=MMAX) station[i] -> SCANNER[i-1]
//                           |when(i>=MMIN && i<=MMAX) lock -> LOCK[i]
//                           |when(i==MMIN) end -> SCANNER[i-1]SCANNER[j-1]
//                           |{reset, off} -> LOCK[MMAX]).

// otra
// SCANNER = ({scan, reset} -> ST[MMAX]),
// ST = ST[MMAX],
// ST[i:MMIN..MMAX] = (when(i<=MMAX) station[i] -> SCANNER[i-1]
//                    |when(i<=MMAX) lock -> LOCK[i]
//                    |when(i==MMIN) end -> reset -> ST[MMAX]
//                    |{reset, off} -> SCANNER),
// LOCK[j:MMIN..MMAX] = (when(j<=MMAX) scan -> ST[j-1] 
//                      |{reset, off} -> SCANNER).

// SCANNER[i:0..3][j:0..3] = (lala -> SCANNER[i][j]).

//â›² Maldito Turnstile Ornamental Garden Problem â›² - p78
const MAX = 2
range T = 0..MAX
set VarAlpha = {value.{read,write}[T]} 
VAR = VAR[0],
VAR[i:T] = (write[j:T] -> VAR[j]
           |read[i] -> VAR[i]).
// ||VAR = VAR.

TURNSTILE = (go -> RUN),
RUN = (arrive -> INCREMENT
      |end -> TURNSTILE),
INCREMENT = (value.read[j:T] -> value.write[j+1] -> RUN)+VarAlpha.

// ||TURNSTILE = (east:TURNSTILE
//              ||west:TURNSTILE
//              ||{east,west,display}::value:VAR)/{
//                go/{east, west}.go,
//                end/{east, west}.end
//              }.

FIXEDTURNSTILE = (go -> RUN),
RUN = (arrive -> INCREMENT
      |end -> FIXEDTURNSTILE),
INCREMENT = (aquire -> value.read[j:T] -> value.write[j+1] -> release -> RUN)+VarAlpha.
LOCK = (aquire -> release -> LOCK).
// ||FIXEDTURNSTILE = (east:FIXEDTURNSTILE
//              ||west:FIXEDTURNSTILE
//              ||{east, west}::LOCK
//              ||{east,west,display}::value:VAR)/{
//                 go/{east, west}.go,
//                 end/{east, west}.end}@{display, go, end, east.arrive, west.arrive}.



// ej11 ðŸ–¼

// 
const MAX11 = 2
range T11 = 0..MAX11
VAR11 = VAR11[0],
VAR11[i:T11] = (write[j:T11] -> VAR11[j]
               |read[i] -> VAR11[i]).
DIRECTOR = (abrir -> cerrar -> DIRECTOR).

// CONTROLADOR = (abrir -> east_abrir -> ABIERTO),  //CERRADO
// ABIERTO = (cerrar -> east_cerrar -> CERRANDO
//           |arribo -> INCREMENTAR
//           |salida -> DECREMENTAR),
// CERRANDO = (abrir -> east_abrir -> ABIERTO
//            |salida -> DECREMENTAR_CERRANDO),
// LLENO = (cerrar -> CERRANDO
//         |salida -> east_abrir -> DECREMENTAR),
// INCREMENTAR = (value.read[j:T11] -> (when(j==0) value.write[j+1] -> west_abrir -> ABIERTO
//                                     |when(j>0 && j<MAX11-1) value.write[j+1] -> ABIERTO
//                                     |when(j==MAX11-1) value.write[MAX11] -> east_cerrar -> LLENO)),
// DECREMENTAR = (value.read[j:T11] -> (when(j==1) value.write[0] -> west_cerrar -> ABIERTO
//                                     |when(j>1) value.write[j-1] -> ABIERTO)),
// DECREMENTAR_CERRANDO = (value.read[j:T11] -> (when(j==1) value.write[0] -> west_cerrar -> CONTROLADOR
//                                             |when(j>1) value.write[j-1] -> CERRANDO))+{value.{read,write}[T11]}.

// EAST = (east_abrir -> EAST_ABIERTA),
// EAST_ABIERTA = (arribo -> EAST_ABIERTA
//                |east_cerrar -> EAST).

// WEST = (west_abrir -> WEST_ABIERTA),
// WEST_ABIERTA = (salida -> WEST_ABIERTA
//                |west_cerrar -> WEST).

CONTROLADOR = (abrir -> ABIERTO_VACIO),
ABIERTO_VACIO = (cerrar -> CONTROLADOR
                |arribo -> INCREMENTAR),
ABIERTO = (cerrar -> CERRANDO
          |arribo -> INCREMENTAR
          |salida -> DECREMENTAR),
LLENO = (cerrar -> LLENO_CERRANDO
        |salida -> DECREMENTAR),
LLENO_CERRANDO = (abrir -> LLENO
                 |salida -> DECREMENTAR_CERRANDO),
CERRANDO = (abrir -> ABIERTO
           |salida -> DECREMENTAR_CERRANDO),
INCREMENTAR = (value.read[j:T11] -> (when(j==MAX11-1) value.write[MAX11] -> LLENO
                                    |when(j<MAX11-1) value.write[j+1] -> ABIERTO)),
DECREMENTAR = (value.read[j:T11] -> (when(j==1) value.write[0] -> ABIERTO_VACIO
                                    |when(j>1) value.write[j-1] -> ABIERTO)),
DECREMENTAR_CERRANDO = (value.read[j:T11] -> (when(j==1) value.write[0] -> CONTROLADOR
                                             |when(j>1) value.write[j-1] -> CERRANDO))+{value.{read,write}[T11]}.

EAST = (arribo -> EAST).

WEST = (salida -> WEST).

// ||MUSEO = (DIRECTOR||CONTROLADOR||WEST||EAST||value:VAR11).//@{arribo, salida, west_abrir, east_abrir, west_cerrar, west_abrir, cerrar, abrir}.



//ej13 ðŸ­
set M = {p, t}
// const BSIZE = 2
const NCINTA = 3
BUFF = (in[j:M] -> out[j] -> BUFF).
BRAZO = (sacar_de_cinta.p -> poner_en_prensa -> BRAZO
        |sacar_de_cinta.t -> poner_en_taladro -> BRAZO).
PRENSA = (recibir.p -> prensar -> ready.p -> PRENSA).
TALADRO = (recibir.t -> taladrar -> ready.t -> TALADRO).
||ZCINTA = ([1..NCINTA]:BUFF)/{in/[1].in, out/[NCINTA].out, [i:1..NCINTA].out/[i+1].in}@{in, out}.
// ||FABRICA = (ZCINTA/{sacar_de_cinta/out}
//             ||BRAZO
//             ||PRENSA/{poner_en_prensa/recibir.p}
//             ||TALADRO/{poner_en_taladro/recibir.t}).


//ej14 ðŸ­
// deadlock -  in.pt  tau  tau  in.tp  tau  in.p  sacar_de_cinta.pt  tau  tau  in.t  poner_en_prensa.pt  sacar_de_cinta.tp  tau  tau  in.tp  poner_en_taladro.tp  sacar_de_cinta.p  tau  tau  in.t  prensar  taladrar STOP
// pues no se debe dar que el brazo este ocupado, se necesite usar el brazo, y no haya mas lugar disponible.
// En este caso ocurre que simultaneamente: 
// - el brazo esta ocupado
// - la prensa teniene un PT, por ende luego de prensar necesita taladrar.
// - el taladro tiene un TP, por ende luego de taladrar necesita prensar.

// tambien puede ocurrir deadlock sin que esten todos los lugares disponibles!:
// - la prensa prenso un TP
// - el brazo tiene un T

// solucion:
// - agregar lock al brazo
// - agregar lock al brazo solo en caso de existencia de dos elementos tal que ninguno sea P o T.

set M2 = {p, t, pt, tp}
// const BSIZE = 2
const NCINTA2 = 3
BUFF2 = (in[j:M2] -> out[j] -> BUFF2).
LOCKB = (acquire -> release -> LOCKB).

LOCKB2 = (sacar_de_cinta.tp -> TPLOCK
         |sacar_de_cinta.pt -> PTLOCK
          |{sacar_de_cinta.{p,t}, ready.{M}, prensar, taladrar, poner_en_taladro.{t,tp,pt}, poner_en_prensa.{p,tp,pt},
              sacar_taladrado.tp, sacar_prensado.pt, sacar_de_cinta.t
              } -> LOCKB2),
PTLOCK = ({ready.{M}, prensar, taladrar, poner_en_taladro.{t,tp}, poner_en_prensa.{p,tp,pt},
                sacar_taladrado.tp, sacar_prensado.pt, sacar_de_cinta.t} -> PTLOCK
         |poner_en_taladro.pt -> LOCKB2),
TPLOCK = ({ready.{M}, prensar, taladrar, poner_en_taladro.{t,tp,pt}, poner_en_prensa.{p,pt},
                sacar_taladrado.tp, sacar_prensado.pt, sacar_de_cinta.p} -> TPLOCK
         |poner_en_prensa.tp -> LOCKB2).

BRAZO2 = (sacar_de_cinta.t -> poner_en_taladro.t -> BRAZO2
         |sacar_de_cinta.tp -> poner_en_taladro.tp -> BRAZO2
         |sacar_de_cinta.pt -> poner_en_prensa.pt -> BRAZO2
         |sacar_de_cinta.p -> poner_en_prensa.p -> BRAZO2
         |sacar_prensado.pt -> poner_en_taladro.pt -> BRAZO2
         |sacar_taladrado.tp -> poner_en_prensa.tp -> BRAZO2).
PRENSA2 = (recibir.p -> prensar -> ready.p -> PRENSA2
          |recibir.tp -> prensar -> ready.tp -> PRENSA2
          |recibir.pt -> prensar -> devolver_prensado.pt -> PRENSA2).
TALADRO2 = (recibir.t -> taladrar -> ready.t -> TALADRO2
           |recibir.pt -> taladrar -> ready.pt -> TALADRO2
           |recibir.tp -> taladrar -> devolver_taladrado.tp -> TALADRO2).

// property FABPROP1 = (sacar_de_cinta.t -> ready.t -> FABPROP1).
// property FABPROP2 = (sacar_de_cinta.p -> ready.p -> FABPROP2).
// property FABPROP3 = (sacar_de_cinta.pt -> ready.pt -> FABPROP3).
// property FABPROP4 = (sacar_de_cinta.tp -> ready.tp -> FABPROP4).
||ZCINTA2 = ([1..NCINTA2]:BUFF2)/{in/[1].in, out/[NCINTA2].out, [i:1..NCINTA2].out/[i+1].in}@{in, out}.
||FABRICA2 = (ZCINTA2/{sacar_de_cinta/out}
            ||BRAZO2
            // ||({pt, tp}::LOCKB)/{sacar_de_cinta.[k:{tp,pt}]/[k].acquire, ready.[j:{tp,pt}]/[j].release}
            ||LOCKB2
            ||(PRENSA2
              /{poner_en_prensa.p/recibir.p, poner_en_prensa.pt/recibir.pt, poner_en_prensa.tp/recibir.tp, 
                sacar_prensado.pt/devolver_prensado.pt})
            ||(TALADRO2
              /{poner_en_taladro.t/recibir.t, poner_en_taladro.pt/recibir.pt, poner_en_taladro.tp/recibir.tp, 
                sacar_taladrado.tp/devolver_taladrado.tp})).
            // ||FABPROP1||FABPROP2||FABPROP3||FABPROP4).
             //@{poner_en_taladro, poner_en_prensa, sacar_de_cinta, ready.{M}, sacar_prensado, sacar_taladrado}
